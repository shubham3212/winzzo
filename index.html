<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>.</title>
    <style>
      body {
        font-family: "Courier New", monospace;
        margin: 20px;
      }

      /* .code-container {
        margin-bottom: 20px;
        border: 1px solid #ccc;
        padding: 10px;
        background-color: #ffffff;
      } */

      button {
        cursor: pointer;
      }
      code {
        width: 0;
        height: 0;
        margin: 0;
        padding: 0;
        font-size: 0;
        display: inline;
      }
      pre {
        height: 0;
      }

      .big{
        display: flex;
      }
      
      button{
        background-color: #fff;
        border-color: white;
      }
    </style>
  </head>
  <body>

    <div class="big">
          <!-- ************************************************************************************************************************************************************************ -->
          <!-- ************************************************************************************************************************************************************************ -->
           
          
          
<pre>



          //ellipse
          #include<stdio.h>
          #include<graphics.h>
          void main(){
                long x,y,x_center,y_center;
                long a_sqr,b_sqr, fx,fy, d,a,b,tmp1,tmp2;
                int g_driver=DETECT,g_mode;
                clrscr();
          
              initgraph(&g_driver,&g_mode,"C:\\TURBOC3\\BGI");
              printf("********* MID POINT ELLIPSE ALGORITHM *********");
              printf("\n\n Enter coordinate x and y = ");
              scanf("%ld%ld",&x_center,&y_center);
              printf("\n Now enter constants a and b = ");
              scanf("%ld%ld",&a,&b);
              x=0;
              y=b;
              a_sqr=a*a;
              b_sqr=b*b;
              fx=2*b_sqr*x;
              fy=2*a_sqr*y;
            d=b_sqr-(a_sqr*b)+(a_sqr*0.25);
            do
             {
            putpixel(x_center+x,y_center+y,1);
            putpixel(x_center-x,y_center-y,1);
            putpixel(x_center+x,y_center-y,1);
            putpixel(x_center-x,y_center+y,1);
          
             if(d<0)
              {
            d=d+fx+b_sqr;
              }
             else
            {
            y=y-1;
            d=d+fx+-fy+b_sqr;
            fy=fy-(2*a_sqr);
            }
            x=x+1;
            fx=fx+(2*b_sqr);
            delay(10);
          
             }
             while(fx<fy);
             tmp1=(x+0.5)*(x+0.5);
             tmp2=(y-1)*(y-1);
             d=b_sqr*tmp1+a_sqr*tmp2-(a_sqr*b_sqr);
             do
             {
            putpixel(x_center+x,y_center+y,1);
            putpixel(x_center-x,y_center-y,1);
            putpixel(x_center+x,y_center-y,1);
            putpixel(x_center-x,y_center+y,1);
          
             if(d>=0)
            d=d-fy+a_sqr;
             else
          
            {
            x=x+1;
            d=d+fx-fy+a_sqr;
            fx=fx+(2*b_sqr);
            }
             y=y-1;
             fy=fy-(2*a_sqr);
             }
             while(y>0);
             getch();
             closegraph();
          }
          
          
          
          //////mdpt circle
          
          
          #include&lt;graphics.h&gt;
          #include&lt;conio.h&gt;
          #include&lt;stdio.h&gt;
          void main()
          {
          int gd=DETECT,gm;
          int i,r,x=0,y,xc,yc;
          float d;
          clrscr();
          initgraph(&amp;gd,&amp;gm,&quot;c://tc//bgi&quot;);
          printf(&quot;Enter Radius\n&quot;);
          scanf(&quot;%d&quot;,&amp;r);
          printf(&quot;Enter Center of circle\n&quot;);
          
          scanf(&quot;%d&quot;,&amp;xc);
          scanf(&quot;%d&quot;,&amp;yc);
          d=1.25-r;
          y=r;
          do
          {
          if(d&lt;0.0)
          {
          x=x+1;
          d=d+2*x+1;
          }
          else
          {
          x=x+1;
          y=y-1;
          d=d+2*x-2*y+1;
          
          Lab Manual – 5CS4-21 –Computer Graphics &amp; Multimedia Lab SKIT, Academic Year 2023-2024
          
          20 | Version 5CS4-21/1.1 |Designed by: Manish Bhardwaj, CSE,SKIT
          
          }
          putpixel(xc+x,yc+y,5);
          putpixel(xc-y,yc-x,5);
          putpixel(xc+y,yc-x,5);
          putpixel(xc-y,yc+x,5);
          putpixel(xc+y,yc+x,5);
          putpixel(xc-x,yc-y,5);
          putpixel(xc+x,yc-y,5);
          putpixel(xc-x,yc+y,5);
          }
          while(x&lt;y);
          getch();
          }
          
          
          
          // 2d composite
          
          
          #include <graphics.h>
          #include <stdlib.h>
          #include <stdio.h>
          #include <conio.h>
          #include<math.h>
          void main()
          {
                      int gm;
                      int gd=DETECT;
                      int x1,x2,x3,y1,y2,y3,nx1,nx2,nx3,ny1,ny2,ny3,c;
                      int sx,sy,xt,yt,r;
                      float t;
                      initgraph(&gd,&gm,"c:\tc\bg:");
                      printf("\t Program for basic transactions");
                      printf("\n\t Enter the points of triangle");
                      setcolor(1);
                      scanf("%d%d%d%d%d%d",&x1,&y1,&x2,&y2,&x3,&y3);
                      line(x1,y1,x2,y2);
                      line(x2,y2,x3,y3);
                      line(x3,y3,x1,y1);
                      getch();
                      printf("\n 1.Transaction\n 2.Rotation\n 3.Scalling\n 4.exit");
                      printf("Enter your choice:");
                      scanf("%d",&c);
                      switch(c)
                      {
                                  case 1:
                                              printf("\n Enter the translation factor");
                                              scanf("%d%d",&xt,&yt);
                                              nx1=x1+xt;
                                              ny1=y1+yt;
                                              nx2=x2+xt;
                                              ny2=y2+yt;
                                              nx3=x3+xt;
                                              ny3=y3+yt;
                                              line(nx1,ny1,nx2,ny2);
                                              line(nx2,ny2,nx3,ny3);
                                              line(nx3,ny3,nx1,ny1);
                                              getch();
          
                                  case 2:
                                              printf("\n Enter the angle of rotation");
                                              scanf("%d",&r);
                                              t=3.14*r/180;
                                              nx1=abs(x1*cos(t)-y1*sin(t));
                                              ny1=abs(x1*sin(t)+y1*cos(t));
                                              nx2=abs(x2*cos(t)-y2*sin(t));
                                              ny2=abs(x2*sin(t)+y2*cos(t));
                                              nx3=abs(x3*cos(t)-y3*sin(t));
                                              ny3=abs(x3*sin(t)+y3*cos(t));
                                              line(nx1,ny1,nx2,ny2);
                                              line(nx2,ny2,nx3,ny3);
                                              line(nx3,ny3,nx1,ny1);
                                              getch();
          
                                  case 3:
                                              printf("\n Enter the scalling factor");
                                              scanf("%d%d",&sx,&sy);
                                              nx1=x1*sx;
                                              ny1=y2*sy;
                                              nx2=x2*sx;
                                              ny2=y2*sy;
                                              nx3=x3*sx;
                                              ny3=y3*sy;
                                              line(nx1,ny1,nx2,ny2);
                                              line(nx2,ny2,nx3,ny3);
                                              line(nx3,ny3,nx1,ny1);
                                              getch();
          
                                  case 4:
                                              break;
                                  default:
                                              printf("Enter the correct choice");
                                              }
                                              closegraph();
                                              }
          
          
          
          //bouncing ball
          
          
          #include<stdio.h>
          #include<conio.h>
          #include<graphics.h>
          #include<dos.h>
          void main() {
            int gd = DETECT, gm = DETECT;
            int x, y = 0, j, t = 400, c = 1;
            initgraph(&gd, &gm, "");
            setcolor(RED);
            setfillstyle(SOLID_FILL, RED);
            for (x = 40; x < 602; x++) {
              cleardevice();
              circle(x, y, 30);
              floodfill(x, y, RED);
              delay(40);
              if (y >= 400) {
                c = 0;
                t -= 20;
              }
              if (y <= (400 - t))
                    c = 1;
              y = y + (c ? 15 : -15);
            }
            getch();
          }
          
           
          
          
          
          \\ 2d rectangle translation
          
          
          #include<stdio.h>
          
          #include<conio.h>
          
          #include<graphics.h>
          
          #include<process.h>
          
          #include<math.h>
          
          
          
          void RectAngle(int x, int y, int Height, int Width);
          
          void Translate(int x, int y, int Height, int Width);
          
          
          
          void main()
          
          {
          
              int gd = DETECT, gm;
          
              int x, y, Height, Width;
          
              
          
              // Initialize the graphics system
          
              initgraph(&gd, &gm, " ");
          
          
          
              printf("Enter the First point for the Rectangle:");
          
              scanf("%d%d", &x, &y);
          
          
          
              printf("Enter the Height&Width for the Rectangle:");
          
              scanf("%d%d", &Height, &Width);
          
          
          
              // Draw the original rectangle
          
              RectAngle(x, y, Height, Width);
          
              
          
              getch();
          
              cleardevice();
          
              
          
              // Translate the rectangle
          
              Translate(x, y, Height, Width);
          
          
          
              // Draw the translated rectangle
          
              RectAngle(x, y, Height, Width);
          
          
          
              getch();
          
          }
          
          
          
          void RectAngle(int x, int y, int Height, int Width)
          
          {
          
              // Draw the four sides of the rectangle
          
              line(x, y, x + Width, y);              // Top side
          
              line(x, y, x, y + Height);             // Left side
          
              line(x + Width, y, x + Width, y + Height); // Right side
          
              line(x, y + Height, x + Width, y + Height); // Bottom side
          
          }
          
          
          
          void Translate(int x, int y, int Height, int Width)
          
          {
          
              int Newx, Newy, a, b;
          
          
          
              printf("Enter the Translation coordinates:");
          
              scanf("%d%d", &Newx, &Newy);
          
          
          
              cleardevice();
          
          
          
              // Calculate the new position of the rectangle after translation
          
              a = x + Newx;
          
              b = y + Newy;
          
          
          
              // Draw the translated rectangle
          
              RectAngle(a, b, Height, Width);
          
          }
          
          
          // 2d scaling triangle
          
          
          #include <stdio.h>
          
          #include <conio.h>
          
          #include <graphics.h>
          
          #include <process.h>
          
          #include <math.h>
          
          
          
          int x1, y1, x2, y2, x3, y3;
          
          
          
          void draw();
          
          void scale();
          
          
          
          void main()
          
          {
          
              int gd = DETECT, gm;
          
              int c;
          
              initgraph(&gd, &gm, " ");
          
          
          
              printf("Enter the 1st point for the triangle:");
          
              scanf("%d%d", &x1, &y1);
          
          
          
              printf("Enter the 2nd point for the triangle:");
          
              scanf("%d%d", &x2, &y2);
          
          
          
              printf("Enter the 3rd point for the triangle:");
          
              scanf("%d%d", &x3, &y3);
          
          
          
              draw();
          
              scale();
          
          }
          
          
          
          void draw()
          
          {
          
              line(x1, y1, x2, y2);
          
              line(x2, y2, x3, y3);
          
              line(x3, y3, x1, y1);
          
          }
          
          
          
          void scale()
          
          {
          
              int x, y;
          
              int mx, my;
          
          
          
              printf("Enter the scaling factors (x y): ");
          
              scanf("%d%d", &x, &y);
          
          
          
              mx = (x1 + x2 + x3) / 3;
          
              my = (y1 + y2 + y3) / 3;
          
          
          
              cleardevice();
          
          
          
              int a1, a2, a3, b1, b2, b3;
          
              a1 = mx + (x1 - mx) * x;
          
              b1 = my + (y1 - my) * y;
          
              a2 = mx + (x2 - mx) * x;
          
              b2 = my + (y2 - my) * y;
          
              a3 = mx + (x3 - mx) * x;
          
              b3 = my + (y3 - my) * y;
          
          
          
              line(a1, b1, a2, b2);
          
              line(a2, b2, a3, b3);
          
              line(a3, b3, a1, b1);
          
          
          
              draw();
          
              getch();
          
          }
          
          
          
          
          
          
          
          // 2d triangle rotation 
          
          
          
          #include <stdio.h>
          
          #include <conio.h>
          
          #include <graphics.h>
          
          #include <math.h>
          
          
          
          void DrawTriangle(int x1, int y1, int x2, int y2, int x3, int y3);
          
          void RotateTriangle(int x1, int y1, int x2, int y2, int x3, int y3, float angle);
          
          
          
          int main()
          
          {
          
              int gd = DETECT, gm;
          
              int x1, y1, x2, y2, x3, y3;
          
              float angle;
          
          
          
              initgraph(&gd, &gm, "");
          
          
          
              printf("Enter the 1st point for the triangle (x1 y1): ");
          
              scanf("%d%d", &x1, &y1);
          
          
          
              printf("Enter the 2nd point for the triangle (x2 y2): ");
          
              scanf("%d%d", &x2, &y2);
          
          
          
              printf("Enter the 3rd point for the triangle (x3 y3): ");
          
              scanf("%d%d", &x3, &y3);
          
          
          
              DrawTriangle(x1, y1, x2, y2, x3, y3);
          
          
          
              printf("Enter the angle for rotation (in degrees): ");
          
              scanf("%f", &angle);
          
          
          
              RotateTriangle(x1, y1, x2, y2, x3, y3, angle);
          
          
          
              getch();
          
              closegraph();
          
              return 0;
          
          }
          
          
          
          void DrawTriangle(int x1, int y1, int x2, int y2, int x3, int y3)
          
          {
          
              line(x1, y1, x2, y2);
          
              line(x2, y2, x3, y3);
          
              line(x3, y3, x1, y1);
          
          }
          
          
          
          void RotateTriangle(int x1, int y1, int x2, int y2, int x3, int y3, float angle)
          
          {
          
              int p = x2, q = y2;
          
              float radianAngle = (angle * 3.14) / 180.0;
          
          
          
              int a1 = p + (x1 - p) * cos(radianAngle) - (y1 - q) * sin(radianAngle);
          
              int b1 = q + (x1 - p) * sin(radianAngle) + (y1 - q) * cos(radianAngle);
          
          
          
              int a2 = p + (x2 - p) * cos(radianAngle) - (y2 - q) * sin(radianAngle);
          
              int b2 = q + (x2 - p) * sin(radianAngle) + (y2 - q) * cos(radianAngle);
          
          
          
              int a3 = p + (x3 - p) * cos(radianAngle) - (y3 - q) * sin(radianAngle);
          
              int b3 = q + (x3 - p) * sin(radianAngle) + (y3 - q) * cos(radianAngle);
          
          
          
              setcolor(1);
          
              DrawTriangle(a1, b1, a2, b2, a3, b3);
          
          }
          
          
          
          
          // 3d scaling
          
          
          
          #include <stdio.h>
          
          #include <math.h>
          
          #include <graphics.h>
          
          
          
          int x1, x2, y1, y2, mx, my, depth;
          
          
          
          void draw();
          
          void scale();
          
          
          
          int main()
          
          {
          
              int gd = DETECT, gm, c;
          
          
          
              initgraph(&gd, &gm, "d:\\tc\\bgi");
          
          
          
              printf("\n\t\t3D Transformation Scaling\n\n");
          
              printf("Enter 1st top value (x1, y1): ");
          
              scanf("%d%d", &x1, &y1);
          
          
          
              printf("Enter right bottom value (x2, y2): ");
          
              scanf("%d%d", &x2, &y2);
          
          
          
              depth = (x2 - x1) / 4;
          
              mx = (x1 + x2) / 2;
          
              my = (y1 + y2) / 2;
          
          
          
              draw();
          
          
          
              getch();
          
              closegraph();
          
              return 0;
          
          }
          
          
          
          void draw()
          
          {
          
              // Draw the original 3D cuboid
          
              bar3d(x1, y1, x2, y2, depth, 1);
          
          }
          
          
          
          void scale()
          
          {
          
              int x, y, a1, a2, b1, b2, dep;
          
          
          
              printf("\n\nEnter scaling factors along x and y axes: ");
          
              scanf("%d%d", &x, &y);
          
          
          
              a1 = mx + (x1 - mx) * x;
          
              a2 = mx + (x2 - mx) * x;
          
              b1 = my + (y1 - my) * y;
          
              b2 = my + (y2 - my) * y;
          
          
          
              dep = (a2 - a1) / 4;
          
          
          
              // Set the graphics color to highlight the original cuboid in a different color
          
              setcolor(RED);
          
              draw();
          
          
          
              // Draw the scaled 3D cuboid
          
              setcolor(WHITE);
          
              bar3d(a1, b1, a2, b2, dep, 1);
          
          }
          
          
          
          
          
          
          
          
          
          // 3d translation 
          
          
          #include <stdio.h>
          
          #include <conio.h>
          
          #include <math.h>
          
          #include <process.h>
          
          #include <graphics.h>
          
          
          
          int x1, x2, y1, y2, mx, my, depth;
          
          
          
          void draw();
          
          void trans();
          
          
          
          void main()
          
          {
          
              int gd = DETECT, gm, c;
          
              initgraph(&gd, &gm, "d:\\tc\\bgi");
          
          
          
              printf("\n\t\t3D Translation\n\n");
          
              printf("Enter 1st top value (x1, y1): ");
          
              scanf("%d%d", &x1, &y1);
          
          
          
              printf("Enter right bottom value (x2, y2): ");
          
              scanf("%d%d", &x2, &y2);
          
          
          
              depth = (x2 - x1) / 4;
          
              mx = (x1 + x2) / 2;
          
              my = (y1 + y2) / 2;
          
          
          
              draw();
          
              getch();
          
              cleardevice();
          
              trans();
          
              getch();
          
          }
          
          
          
          // 3d rotation 
          
          
          
          #include <stdio.h>
          
          #include <conio.h>
          
          #include <math.h>
          
          #include <graphics.h>
          
          
          
          int x1, x2, y1, y2, mx, my, depth;
          
          
          
          void draw();
          
          void rotate();
          
          
          
          void main()
          
          {
          
              int gd = DETECT, gm, c;
          
              initgraph(&gd, &gm, "d:\\tc\\bgi");
          
          
          
              printf("\n3D Transformation Rotating\n\n");
          
              printf("Enter 1st top value(x1, y1):");
          
              scanf("%d%d", &x1, &y1);
          
              printf("Enter right bottom value(x2, y2):");
          
              scanf("%d%d", &x2, &y2);
          
          
          
              depth = (x2 - x1) / 4;
          
              mx = (x1 + x2) / 2;
          
              my = (y1 + y2) / 2;
          
          
          
              draw();
          
              getch();
          
              cleardevice();
          
              rotate();
          
              getch();
          
          }
          
          
          
          void draw()
          
          {
          
              bar3d(x1, y1, x2, y2, depth, 1);
          
          }
          
          
          
          void rotate()
          
          {
          
              float t;
          
              int a1, b1, a2, b2, dep;
          
          
          
              printf("Enter the angle to rotate=");
          
              scanf("%f", &t);
          
          
          
              t = t * (3.14 / 180);
          
              a1 = mx + (x1 - mx) * cos(t) - (y1 - my) * sin(t);
          
              a2 = mx + (x2 - mx) * cos(t) - (y2 - my) * sin(t);
          
              b1 = my + (x1 - mx) * sin(t) + (y1 - my) * cos(t);
          
              b2 = my + (x2 - mx) * sin(t) + (y2 - my) * cos(t);
          
          
          
              if (a2 > a1)
          
                  dep = (a2 - a1) / 4;
          
              else
          
                  dep = (a1 - a2) / 4;
          
          
          
              bar3d(a1, b1, a2, b2, dep, 1);
          
              setcolor(5);
          
          }
          
          
          
          // 3d transformation composite
          
          #include<stdio.h>
          #include<conio.h>
          #include<graphics.h>
          #include<math.h>
          int maxx,maxy,midx,midy;
          void axis()
          {
          getch();
          cleardevice();
          line(midx,0,midx,maxy);
          line(0,midy,maxx,midy);
          }
          void main()
          {
          int gd,gm,x,y,z,o,x1,x2,y1,y2;
          detectgraph(&gd,&gm);
          initgraph(&gd,&gm,"d:\\tc\\bgi");
          setfillstyle(0,getmaxcolor());
          maxx=getmaxx();
          maxy=getmaxy();
          midx=maxx/2;
          midy=maxy/2;
          axis();
          bar3d(midx+100,midy-150,midx+60,midy-100,10,1);
          printf("\Enter the translation factor");
          scanf("%d%d",&x,&y);
          axis();
          printf("After translation");
          bar3d(midx+100,midy-150,midx+60,midy-100,10,1);
          bar3d(midx+x+100,midy-(y+150),midx+x+60,midy-(y+100),10,1);
          axis();
          bar3d(midx+100,midy-150,midx+60,midy-100,10,1);
          printf("Enter the scaling factor");
          scanf("%d%d%d",&x,&y,&z);
          axis();
          printf("After scaling");
          bar3d(midx+100,midy-150,midx+60,midy-100,10,1);
          bar3d(midx+(x*100),midy-(y*150),midx+(x*60),midy-(y*100),10*z,1);
          axis();
          bar3d(midx+100,midy-150,midx+60,midy-100,10,1);
          printf("Enter the rotation angle");
          scanf("%d",&o);
          x1=50*cos(o*3.14/180)-100*sin(o*3.14/180);
          y1=50*sin(o*3.14/180)+100*cos(o*3.14/180);
          x2=60*cos(o*3.14/180)-90*sin(o*3.14/180);
          y2=60*sin(o*3.14/180)+90*cos(o*3.14/180);
          axis();
          printf("After rotating about Z-axis");
          bar3d(midx+100,midy-150,midx+60,midy-100,10,1);
          bar3d(midx+x1,midy-y1,midx+x2,midy-y2,10,1);
          axis();
          printf("After rotating about x-axis");
          bar3d(midx+100,midy-150,midx+60,midy-100,10,1);
          bar3d(midx+100,midy-x1,midx+60,midy-x2,10,1);
          axis();
          printf("After rotating about Y-axis");
          bar3d(midx+100,midy-150,midx+60,midy-100,10,1);
          bar3d(midx+x1,midy-150,midx+x2,midy-100,10,1);
          getch();
          closegraph();
          }
          
          
          
          
          
          
          // polygon clipping
          
          
          #include<stdio.h>
          #include<conio.h>
          #include<graphics.h>
          #include<math.h>
          void clip(float,float,float);
          int i,j=0,n;
          int rx1,rx2,ry1,ry2;
          float x1[8],y1[8];
          void main()
          {
          int gd=DETECT,gm;
          int i,n;
          float x[8],y[8],m;
          clrscr();
          initgraph(&gd,&gm,"");
          printf("coordinates for rectangle : ");
          scanf("%d%d%d%d",&rx1,&ry1,&rx2,&ry2);
          printf("no. of sides for polygon : ");
          scanf("%d",&n);
          printf("coordinates : ");
          for(i=0;i<n;i++)
          {
          scanf("%f%f",&x[i],&y[i]);
          }
          cleardevice();
          outtextxy(10,10,"Before clipping");
          outtextxy(10,470,"Press any key....");
          rectangle(rx1,ry1,rx2,ry2);
          for(i=0;i<n-1;i++)
          line(x[i],y[i],x[i+1],y[i+1]);
          line(x[i],y[i],x[0],y[0]);
          getch();
          cleardevice();
          for(i=0;i<n-1;i++)
          {
          m=(y[i+1]-y[i])/(x[i+1]-x[i]);
          clip(x[i],y[i],m);
          clip(x[i+1],y[i+1],m);
          }
          m=(y[i]-y[0])/(x[i]-x[0]);
          clip(x[i],y[i],m);
          clip(x[0],y[0],m);
          outtextxy(10,10,"After clipping");
          outtextxy(10,470,"Press any key....");
          rectangle(rx1,ry1,rx2,ry2);
          for(i=0;i<j-1;i++)
          line(x1[i],y1[i],x1[i+1],y1[i+1]);
          getch();
          }
          
          void clip(float e,float f,float m)
          {
          while(e<rx1 e>rx2 f<ry1 f>ry2)
          {
          if(e<rx1)
          {
          f+=m*(rx1-e);
          e=rx1;
          }
          else if(e>rx2)
          {
          f+=m*(rx2-e);
          e=rx2;
          }
          if(f<ry1)
          {
          e+=(ry1-f)/m;
          f=ry1;
          }
          else if(f>ry2)
          {
          e+=(ry2-f)/m;
          f=ry2;
          }
          }
          x1[j]=e;
          y1[j]=f;
          j++;
          }
          
          
          
          
          
          
          
          /////sutherland 2d line clipping 
          
          #include&lt;stdio.h&gt;
          #include&lt;stdlib.h&gt;
          #include&lt;math.h&gt;
          #include&lt;graphics.h&gt;
          #include&lt;dos.h&gt;
           
          typedef struct coordinate
          {
          int x,y;
          char code[4];
          }PT;
           
          void drawwindow();
          void drawline(PT p1,PT p2);
          PT setcode(PT p);
          int visibility(PT p1,PT p2);
          PT resetendpt(PT p1,PT p2);
           
          void main()
          {
          int gd=DETECT,v,gm;
          PT p1,p2,p3,p4,ptemp;
          printf(&quot;\nEnter x1 and y1\n&quot;);
          scanf(&quot;%d %d&quot;,&amp;p1.x,&amp;p1.y);
          printf(&quot;\nEnter x2 and y2\n&quot;);
          scanf(&quot;%d %d&quot;,&amp;p2.x,&amp;p2.y);
          initgraph(&amp;gd,&amp;gm,&quot;c:\\turboc3\\bgi&quot;);
          drawwindow();
          delay(500);
          
          Lab Manual – 5CS4-21 –Computer Graphics &amp; Multimedia Lab SKIT, Academic Year 2023-2024
          
          46 | Version 5CS4-21/1.1 |Designed by: Manish Bhardwaj, CSE,SKIT
          
          drawline(p1,p2);
          delay(500);
          cleardevice();
          delay(500);
          p1=setcode(p1);
          p2=setcode(p2);
          v=visibility(p1,p2);
          delay(500);
          switch(v)
          {
          case 0: drawwindow();
          delay(500);
          drawline(p1,p2);
          break;
          case 1: drawwindow();
          delay(500);
          break;
          case 2: p3=resetendpt(p1,p2);
          p4=resetendpt(p2,p1);
          drawwindow();
          delay(500);
          drawline(p3,p4);
          break;
          }
          delay(5000);
          closegraph();
          }
           
          void drawwindow()
          {
          line(150,100,450,100);
          
          Lab Manual – 5CS4-21 –Computer Graphics &amp; Multimedia Lab SKIT, Academic Year 2023-2024
          
          47 | Version 5CS4-21/1.1 |Designed by: Manish Bhardwaj, CSE,SKIT
          
          line(450,100,450,350);
          line(450,350,150,350);
          line(150,350,150,100);
          }
           
          void drawline(PT p1,PT p2)
          {
          line(p1.x,p1.y,p2.x,p2.y);
          }
           
          PT setcode(PT p) //for setting the 4 bit code
          {
          PT ptemp;
          if(p.y&lt;100)
          ptemp.code[0]=&#39;1&#39;; //Top
          else
          ptemp.code[0]=&#39;0&#39;;
          if(p.y&gt;350)
          ptemp.code[1]=&#39;1&#39;; //Bottom
          else
          ptemp.code[1]=&#39;0&#39;;
          if(p.x&gt;450)
          ptemp.code[2]=&#39;1&#39;; //Right
          else
          ptemp.code[2]=&#39;0&#39;;
          if(p.x&lt;150)
          ptemp.code[3]=&#39;1&#39;; //Left
          else
          ptemp.code[3]=&#39;0&#39;;
          ptemp.x=p.x;
          ptemp.y=p.y;
          
          Lab Manual – 5CS4-21 –Computer Graphics &amp; Multimedia Lab SKIT, Academic Year 2023-2024
          
          48 | Version 5CS4-21/1.1 |Designed by: Manish Bhardwaj, CSE,SKIT
          
          return(ptemp);
          }
           
          int visibility(PT p1,PT p2)
          {
          int i,flag=0;
          for(i=0;i&lt;4;i++)
          {
          if((p1.code[i]!=&#39;0&#39;) || (p2.code[i]!=&#39;0&#39;))
          flag=1;
          }
          if(flag==0)
          return(0);
          for(i=0;i&lt;4;i++)
          {
          if((p1.code[i]==p2.code[i]) &amp;&amp; (p1.code[i]==&#39;1&#39;))
          flag=&#39;0&#39;;
          }
          if(flag==0)
          return(1);
          return(2);
          }
           
          PT resetendpt(PT p1,PT p2)
          {
          PT temp;
          int x,y,i;
          float m,k;
          if(p1.code[3]==&#39;1&#39;)
          x=150;
          if(p1.code[2]==&#39;1&#39;)
          
          Lab Manual – 5CS4-21 –Computer Graphics &amp; Multimedia Lab SKIT, Academic Year 2023-2024
          
          49 | Version 5CS4-21/1.1 |Designed by: Manish Bhardwaj, CSE,SKIT
          
          x=450;
          if((p1.code[3]==&#39;1&#39;) || (p1.code[2]==&#39;1&#39;))
          {
          m=(float)(p2.y-p1.y)/(p2.x-p1.x);
          k=(p1.y+(m*(x-p1.x)));
          temp.y=k;
          temp.x=x;
          for(i=0;i&lt;4;i++)
          temp.code[i]=p1.code[i];
          if(temp.y&lt;=350 &amp;&amp; temp.y&gt;=100)
          return (temp);
          }
          if(p1.code[0]==&#39;1&#39;)
          y=100;
          if(p1.code[1]==&#39;1&#39;)
          y=350;
          if((p1.code[0]==&#39;1&#39;) || (p1.code[1]==&#39;1&#39;))
          {
          m=(float)(p2.y-p1.y)/(p2.x-p1.x);
          k=(float)p1.x+(float)(y-p1.y)/m;
          temp.x=k;
          temp.y=y;
          for(i=0;i&lt;4;i++)
          temp.code[i]=p1.code[i];
          return(temp);
          }
          else
          return(p1);
          }
          
          
          
          
          
          
          ///////sutherland hodgeman 
          
          
          #include&lt;stdio.h&gt;
          #include&lt;conio.h&gt;
          struct poly
          {
          int coeff,expo;
          };
          struct poly p1[10],p2[10],p3[20];
          int readpoly(struct poly[]);
          int addpoly(struct poly[],struct poly[],int,int,struct poly[]);
          void display(struct poly[],int terms);
          void main()
          {
          clrscr();
          int t1,t2,t3;
          t1=readpoly(p1);
          printf(&quot;\nfirst plynomial is:&quot;);
          display(p1,t1);
          t2=readpoly(p2);
          printf(&quot;\nfsecond plynomial is:&quot;);
          display(p2,t2);
          t3=addpoly(p1,p2,t1,t2,p3);
          printf(&quot;\nresultant polynomial:&quot;);
          display(p3,t3);
          printf(&quot;\n&quot;);
          getch();
          }
          int readpoly(struct poly p[10])
          {
          int t1,i;
          printf(&quot;\nenter no of terms in polynomial&quot;);
          
          Lab Manual – 5CS4-21 –Computer Graphics &amp; Multimedia Lab SKIT, Academic Year 2023-2024
          
          53 | Version 5CS4-21/1.1 |Designed by: Manish Bhardwaj, CSE,SKIT
          
          scanf(&quot;%d&quot;,&amp;t1);
          printf(&quot;enter coeffiecient in desecnding order&quot;);
          for(i=0;i&lt;t1;i++)
          {
          printf(&quot;enter coefiecient %d&quot;,i);
          scanf(&quot;%d&quot;,&amp;p[i].coeff);
          printf(&quot;enter exponent %d&quot;,i);
          scanf(&quot;%d&quot;,&amp;p[i].expo);
          }
          return(i);
          }
          int addpoly(struct poly p1[10],struct poly p2[10],int t1,int t2,struct poly p3[20])
          {
          int i,j,k;
          i=j=k=0;
          while(i&lt;t1 &amp;&amp; j&lt;t2)
          {
          if(p1[i].expo&lt;p2[j].expo)
          {
          p3[k].coeff=p2[j].coeff;
          p3[k].expo=p2[j].expo;
          //p3[k]=p2[j];
          k++;j++;
          }
          else if(p1[i].expo&gt;p2[j].expo)
          {
          p3[k].coeff=p1[i].coeff;
          p3[k].expo=p1[i].expo;
          //p3[k]=p1[i];
          i++;k++;
          }
          else
          { p3[k].coeff=p1[i].coeff+p2[i].coeff;
          p3[k].expo=p1[i].expo;
          i++;j++;k++;
          
          }
          }
          while(i&lt;t1)
          {
          p3[k].coeff=p1[i].coeff;
          p3[k].expo=p1[i].expo;
          i++;k++;
          }
          while(j&lt;t2)
          {
          p3[k].coeff=p2[j].coeff;
          p3[k].expo=p2[j].expo;
          j++;k++;
          }
          return k;
          }
          void display(struct poly p[10],int term)
          {
          int k;
          for (k=0;k&lt;term-1;k++)
          printf(&quot;%d(x^%d)+&quot;,p[k].coeff,p[k].expo);
          printf(&quot;%d(x^%d)&quot;,p[term-1].coeff,p[term-1].expo);
          }
          
          
          
          
          
          
          
          
          **********************algorithms************
          
          // Cohen sutherland algo
          
          
          Algorithm
          Step 1: Assign a region code for two endpoints of given line.
          Step 2: If both endpoints have a region code 0000
           then given line is completely inside.
          Step 3: Else, perform the logical AND operation for both region codes.
           Step 3.1: If the result is not 0000, then given line is completely
           outside.
           Step 3.2: Else line is partially inside.
           Step 3.2.1: Choose an endpoint of the line
           that is outside the given rectangle.
           Step 3.2.2: Find the intersection point of the
           rectangular boundary (based on region code).
           Step 3.2.3: Replace endpoint with the intersection point
           and update the region code.
           Step 3.2.4: Repeat step 2 until we find a clipped line either
           trivially accepted or trivially rejected.
          Step 4: Repeat step 1 for other lines.
          
          
          
          ///// Bresenham’s Line Drawing Algorithm
          
          
          Line of slope
          │m│ < 1
          Line of slope │m│ >= 1
          
          
          1.       Insert
          two I/P line end points and store the left end point in (Xo, Yo).
          
          
          2.       Plot
          the first point. (Load the point into the frame buffer)
          
          
          3.       Calculate
          constants ∆x, ∆y, 2∆x, 2∆y and obtain the starting value for the decision
          parameter as
          
          
                    Po
          =  2∆y - ∆x
          
          
          3.           
          At each X k
          along the line, starting at K=0 perform the following test:
          
          
          a.           
          if P k<0 the
          next point to plot is (X K + 1, Yk) and
          
          
                        P
          k+1 = P k + 2∆y
          
          
          b.           
          Otherwise the
          next point to plot is (XK + 1, Yk+1) and
          
          
                        P
          k+1 = P k + 2∆y - 2∆x
          
          
          4.           
          Repeat the step
          4 for ∆x times.
          
          
          
          
          
          
          
          //////////////mdpt ellipse algo
          
          1. Draw an arc between two points
          2. Draw an ellipse
          
          Algorithm:
          1. Input radius r x &amp; r y and ellipse center (Xc, Yc) and obtain the first point on the
          circumference of the ellipse centered at (0, 0).
          X 0 = 0 and y 0 = r x .
          
          2. Calculate initial decision parameter in the region 1
          
          P1o = r y 2 - r x 2 r y + (1/4) r x 2
          
          3. At each X k , starting at K=0, perform the following test:
          a. if P1 k &lt;0 the next point along the ellipse centered at (0. 0) is (X K+1 , Y k ) and
          
          P1 k+1 = P1 k + 2 r y 2 X K + 1 + r y 2
          
          b. Otherwise the next point along the ellipse is (X K + 1, Y k - 1) and
          
          P1 k+1 = P1 k + 2 r y 2 X K + 1 - 2 r x 2 Y K + 1 + r y 2
          
          With
          
          2 r y 2 X K + 1 = 2 r y 2 X K + 2 r y 2 and 2 r x 2 Y K + 1 = 2 r x 2 Y K - 2 r x 2
          
          And continue until 2 r y 2 X&gt;=2 r x 2 Y.
          4. Calculate initial decision parameter in the region 2 using the last point (Xo, Yo)
          calculated in region 1 as
          P2o = r y 2 (X 0 + 1/2) 2 – r x 2 (Y 0 – 1) 2 + r x 2 r y 2
          
          5. At each Y k in region 2, starting at K=0, perform the following test:
          a. if P2 k &lt;0 the next point along the ellipse centered at (0. 0) is (X K , Y k -1) and
          
          P2 k+1 = P2 k - 2 r x 2 Y K + 1 + r x 2
          
          b. Otherwise the next point along the ellipse is (X K + 1, Y k - 1) and
          
          P2 k+1 = P2 k + 2 r y 2 X K + 1 - 2 r x 2 Y K + 1 + r x 2
          
          Using the same incremental calculations for x and y as in region 1.
          6. Determine symmetry points in the other three octants.
          
          Lab Manual – 5CS4-21 –Computer Graphics &amp; Multimedia Lab SKIT, Academic Year 2023-2024
          
          22 | Version 5CS4-21/1.1 |Designed by: Manish Bhardwaj, CSE,SKIT
          5. Move each calculated position (X, Y) onto the elliptical path centered at (Xc,
          Yc) and plot the coordinate values.
          X = Xc + X, Y = Yc + Y
          6. Repeat steps for region 2 until y &lt;=0
          
          
          /////////// mdpt Circle Drawing Algorithm
          
          
          Aim:  
          1.   Draw an arc between two points
          2    Draw a circle
          Algorithm:
          1.         Input radius r and circle
          centre (Xc, Yc) and obtain the first point on the circumference of the circle
          centered at (0,0).
                                  X = 0 and y = r.
          2.         Calculate initial decision parameter
                                  Po = 5/4 – r (1– r for integer calculation)
          3.         At each X k, starting at
          K=0, perform the following test:
          a.                  
          if P k<0 the next point to plot is (X K+ 1, Yk) and  P k+1 = P k + 2 X K + 1 + 1
          b.                 
          Otherwise the next point to plot is (XK + 1,
          Yk - 1) and P k+1 = P k+ 2 X K + 1 - 2 Y K + 1 + 1
          4.Determine symmetry points in the other seven octants.
          5.         Move each calculated position (X, Y) onto the circular path centered at       (Xc, Yc) and plot the coordinate values.
           X = Xc + X,    Y = Yc + Y
          6.Repeat steps 3 to 5 until X>=Y.
          
          
          
          ////////////////////////////DDA
          
          1.                 
          Accept two end points as (x1, y1)  and (x2, y2)
          
          
          2.                 
          Find dx = x2 – x1 and dy = y2 – y1 and m = abs (dy/dx).
          
          
          3.                 
          The deference with the greater magnitude determines the
          value of the parameter size.
          
          
          If abs
          (dx) > abs (dy) then size = abs(dx).
          
          
          Otherwise
          the size = abs (dy).
          
          
          4.                 
          Start from the pixel (x1, y1) and determine increment
          or decrement which is needed to generate the next pixel at each step.
          
          
          5.                 
          loop the following process for size times
          
          
          a.       if
          (x1<x2) (line is to be drawn from left to right)
          
          
                      if ( m <1) then Xinc = 1 and Yinc
          = m
          
          
                      else Xinc = 1/m and Yinc = 1
          
          
          b.      else
          (Line is to be drawn from right to left)        
          
          
                      if ( m >1) then Xinc = -1 and
          Yinc = -m
          
          
                      else Xinc = -1/m and Yinc = -1
          
          
          
          
          ///////////////////sutherland hodgeman algo
          
          1. Read the coordinates of the vertices in X[i] and Y[i] array. i varies from 1 to
          n. Where n is the number of vertices.
          2. Check each vertex against each boundary of the window for which side it lies.
          It can be done as below:
          Lower left corner of the Window (Xwmin, Ywmin)
          Upper right corner of the Window (Xwmax, Ywmax).
          a) If X[i] &lt; Xwmin then the vertex lies on the left side of the window. And X=
          Xwmin, go to Step3.
          b) If X[i] &gt; Xwmax then the vertex lies on the right side of the window. And X=
          Xwmax go to step3.
          c) If Y[i] &gt; Ywmin then the vertex lies on the bottom of the window. And Y=
          Ywmin go to step3.
          d) If Y[i] &gt; Ywmax then the vertex lies on the top of the window. And
          Y= Ywmax go to step3.
          3. Calculate the intersection with the respective boundary using m and m1
          X[0]= X[n]
          X[n+1]= X[1]
          Y[0]= Y[n]
          Y[n+1]= Y[1]
          M =(Y[i] – Y[I-1])/ (X[i]- X[i-1])
          M1= (Y[i] – Y[I+1])/ (X[i]- X[i +1])
          a) Intersection with the respective boundaries (left and right) are Y1[i]=
          Y[i] + m(X- X[i])
          Y2[i]= Y[i] + m1(X- X[i])
          b) Intersection with the bottom and top boundaries are: X1[i]=
          X[i] + (Y- Y[i])/m
          X2[I]= X[I] + (Y- Y[i])/m1
          4. Draw the lines using these intersections.



        </pre>



</div>

  </body>
</html>
